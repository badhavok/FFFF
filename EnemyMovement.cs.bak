using UnityEngine;
using System.Collections;

//This is the script used to control all the movement code/functions
[RequireComponent(typeof(Enemy))]
public class EnemyMovement : MonoBehaviour {

	public Transform target;
	public int wavepointIndex = 0;
	private bool runBack = false;
	private bool goLeft;
	private float finalCountdown;
	private bool aboveGround;
	private float wormMove;
	private bool wormStop;

	private Enemy enemy;
	private Animation anim;

	public float pathDistance, timeToDestination, remainingPathDistance;

	void Start()
	{
		//This is used when the enemy is "duplicated" (I.E doesn't start at the beginning of the path)
		enemy = GetComponent<Enemy>();
		anim = gameObject.GetComponent<Animation>();
		if (enemy.fromDropship)
		{
			target = Waypoints.points[wavepointIndex];
			transform.LookAt(target);
		}
		else if (!enemy.fromDropship)
		{
			target = Waypoints.points[0];
			transform.LookAt(target);
		}
		var rand = Random.Range(0, 4);
		finalCountdown = rand;
		pathDistance = Waypoints.totalLength;
		timeToDestination = pathDistance / enemy.speed;
		// essentially starts a countdown to the target.
		// if speed * someTime = PathDistance then someTime = pathDistance/ speed
		remainingPathDistance = pathDistance;
		//starts at max, goes to 0
	}

	void Update()
	{
		if (enemy.stopEnemy || wormStop)
		{

		}
		else if (enemy.speedEnemy)
		{

		}
		else if	(enemy.slowEnemy)
		{
			timeToDestination -= Time.deltaTime / enemy.speed;
			remainingPathDistance -= enemy.speed * Time.deltaTime;
		}
		else
		{
			timeToDestination -= Time.deltaTime;
			remainingPathDistance -= enemy.speed * Time.deltaTime;
		}
		if (enemy.fearEnemy)
		{
			timeToDestination += Time.deltaTime / enemy.speed;
			remainingPathDistance += enemy.speed * Time.deltaTime;
		}

		//Debug.Log("My speed is: " + enemy.speed + "... + Time to destination " + timeToDestination + ". My remaining distance is " + remainingPathDistance);
		Vector3 dir = target.position - transform.position;
		transform.Translate(dir.normalized * enemy.speed * Time.deltaTime, Space.World);
		//Debug.Log("I'm travelling at a speed of " + enemy.speed + " .");

		if (enemy.isFlying && enemy.enemyStats.isHovercraft)
		{
			transform.Translate(Vector3.up * Time.deltaTime / 2, Space.World);
		}
		//"isSpider" is used for any small creatures to make them more animated and 'walk' across the path more freely
		//Might expand this with a variable so normal units can also walk a bit more freely, but less so than larger equivalents to keep them within the viewable path
		if (enemy.isSpider)
		{
			//Which direction am I moving?
			if (goLeft)
			{
				transform.Translate(Vector3.left * Time.deltaTime * 2);
			}
			else
			{
				transform.Translate(Vector3.right * Time.deltaTime * 2);
			}
			//The counter to control how long the enemy is moving to one side
			if (finalCountdown <= 0)
			{
				goLeft = true;
				finalCountdown += 3;
			}
			else if (finalCountdown < 1.5)
			{
				finalCountdown -= Time.deltaTime;
				goLeft = false;
			}
			else
			{
				finalCountdown -= Time.deltaTime;
			}
		}
		if(enemy.isWorm)
		{
			if(aboveGround)
			{
				//remove opaque
				//play animation to raise
				anim.Play("Worm1-up");
				this.gameObject.tag = "Enemy";
				wormStop = true;
			}
			else //moving
			{
				this.gameObject.tag = "Fallen";
				wormStop = false;
				//make worm opaque (how can I show the worm still moving underground?) & stop being targeted (set tag as "Fallen")
				//play animations to lower
				//Move along path
				//stop moving
			}
			if(wormMove <= 0)
			{
				aboveGround = true;
				wormMove += 18;
			}
			else if(wormMove < 6)
			{
				aboveGround = false;
				wormMove -= Time.deltaTime;
			}
			else
			{
				wormMove -= Time.deltaTime;
			}
		}
		//Do I need to run backwards?
		if (enemy.fearEnemy)
		{
			if (!runBack)
			{
				GetLastWaypoint();
				transform.LookAt(target);
				//Debug.Log("Towards : " + target + "");
			}
			else
			{
				if (Vector3.Distance(transform.position, target.position) <= 0.4f)
				{
					//Debug.Log("ONWARDSSS");
					GetLastWaypoint();
					transform.LookAt(target);
				}
			}
		}
		else
		{
			if (runBack)
			{
				GetNextWaypoint();
				transform.LookAt(target);
				//Debug.Log("Towards : " + target + "");
			}
			else
			{
				if (Vector3.Distance(transform.position, target.position) <= 0.4f)
				{
					//Debug.Log("ONWARDSSS");
					GetNextWaypoint();
					transform.LookAt(target);
				}
			}
		}
	}
	//Function to get the last waypoint when running backwards
	void GetLastWaypoint()
	{
		--wavepointIndex;
		target = Waypoints.points[wavepointIndex];
		runBack = true;
	}
	//Function for moving forwards or detecting the enemy is at the end of the path
	void GetNextWaypoint()
	{
		if (wavepointIndex >= Waypoints.points.Length - 1)
		{
			EndPath();
			return;
		}

		//furthestOnPath += 10f;
		++wavepointIndex;
		target = Waypoints.points[wavepointIndex];
		runBack = false;
	}
	//When enemy is at the end path, lose a player life & despawn
	void EndPath()
	{
		--PlayerStats.Lives;
		--WaveSpawner.EnemiesAlive;
		Destroy(gameObject);
	}

}
